module Ninja
  class File
    def initialize(path=nil, &block)
      @variables = []
      @rules = []
      @builds = []
      @defaults = []
      Delegator.new(self, :except => [:save]).instance_eval(&block) if block_given?
      self.save(path) if path
    end

    def variable(name, value)
      @variables.push(Ninja::Variable.new(name, value))
    end

    def rule(name, command, opts={})
      @rules.push(Ninja::Rule.new(:name => name,
                                  :command => command,
                                  :dependencies => opts[:dependencies],
                                  :description => opts.fetch(:description, nil)))
    end

    def build(rule, outputs_to_inputs, options={})
      outputs_to_inputs.each do |output, inputs|
        parameters = { :rule => rule, :inputs => [*inputs], :output => output }

        optional = [:variables, :implicit_deps, :order_only_deps]

        options.find_all{|k,v| optional.include?(k) }.each do |field, value|
          parameters[field] = value
        end

        @builds.push(Ninja::Build.new(parameters))
      end
    end

    def alias(from, to)
      # Pretty clever, huh?
      @builds.push(Ninja::Build.new(:rule => 'phony', :inputs => [*to], :output => from))
    end

    def defaults(outputs)
      # TODO(mtwilliams): Accept variables (\$[\w]|\$\{[\w]\}).
      # raise "Expected output(s) to be paths." unless [*outputs].all?{|output| /\A(?:[-\w\.]+\/?)+\z/.match(output)}
      @defaults.push(*outputs)
    end

    def save(path)
      raise "Path not specified!" unless path
       # TODO(mtwilliams): Check if everything up to |path| exists.
      ::File.open(path, 'w') do |f|
        f.write "# This file was auto-generated by \"#{::File.basename($PROGRAM_NAME, ::File.extname($0))}\".\n"
        f.write "# Do not modify! Instead, modify the aforementioned program.\n\n"
        f.write "# We require Ninja >= 1.3 for `deps` and >= 1.5 for `msvc_deps_prefix`.\n"

        required_version = '1.3'
        required_version = '1.5' if @rules.any?{|r| r.dependencies && r.dependencies == :msvc}
        f.write "ninja_required_version = #{required_version}\n\n"

        @variables.each do |variable|
          # TODO(mtwilliams): Escape.
          f.write "#{variable.name} = #{variable.value}\n"
        end
        f.write "\n" unless @variables.empty?

        @rules.each do |rule|
          f.write "rule #{rule.name}\n"
          if rule.description
            f.write "  description = #{rule.description}\n"
          end
          if rule.dependencies
            if (rule.dependencies == :gcc) or (rule.dependencies == :clang)
              f.write "  depfile = $out.d\n"
              f.write "  deps = gcc\n"
            elsif rule.dependencies == :msvc
              # TODO(mtwilliams): Handle non-English output.
              # f.write "  msvc_deps_prefix = Note: including file: \n"
              f.write "  deps = msvc\n"
            else
              f.write "  depfile = #{rule.dependencies}\n"
            end
          end
          f.write "  command = #{rule.command}\n\n"
        end

        @builds.each do |build|
          f.write "build #{build.output}: #{build.rule} #{build.inputs.join(' ')}"

          if ! build.implicit_deps.empty?
            f.write " | #{build.implicit_deps.join(' ')}"
          end

          if ! build.order_only_deps.empty?
            f.write " || #{build.order_only_deps.join(' ')}"
          end

          f.write "\n"

          build.variables.each do |name, value|
            f.write "  #{name} = #{value}\n"
          end
        end

        unless @defaults.empty?
          f.write "\n" unless @builds.empty?
          f.write "default #{@defaults.join(' ')}\n" unless @defaults.empty?
        end

        # TODO(mtwilliams): Execute other files (via 'subninja').
        # TODO(mtwilliams): Specify pools, to optimize compilation times.
      end
    end
  end
end
